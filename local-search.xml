<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实验室回测系统部署学习</title>
    <link href="/2020/07/25/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/07/25/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>2020-07-19</p><p>2020-07-24</p><h3 id="安装Docker，17-03-x-ce"><a href="#安装Docker，17-03-x-ce" class="headerlink" title="安装Docker，17.03.x-ce"></a>安装Docker，17.03.x-ce</h3><pre><code>$ apt-get update$ curl https://releases.rancher.com/install-docker/17.03.sh | sh</code></pre><p>将用户添加到<code>docker group</code>中：<code>sudo usermod -aG docker [your-user]</code></p><h3 id="安装Rancher1-6容器"><a href="#安装Rancher1-6容器" class="headerlink" title="安装Rancher1.6容器"></a>安装Rancher1.6容器</h3><p>Rancher是一个docker容器管理平台实现对Docker和Kubernetes的轻松部署。</p><pre><code>$ sudo docker run -d --restart=unless-stopped -p 8080:8080 --name rancher-server rancher/server</code></pre><h3 id="管理Rancher"><a href="#管理Rancher" class="headerlink" title="管理Rancher"></a>管理Rancher</h3><p>在ADMIN=&gt;Access Control中设置登录认证，这里使用local。</p><h3 id="添加host"><a href="#添加host" class="headerlink" title="添加host"></a>添加host</h3><p>在INFRASTRUCTURE=&gt;Hosts中点击Add host，使用默认配置并添加Host。如果Host没有正常添加，可以考虑以下处理方法：</p><ol><li>放通500、4500端口。</li><li>删除文件：<code>rm -rf /var/lib/rancher/state</code></li><li>删除agent容器：<code>docker ps</code>并查找带有agent的容器id，并使用<code>docker kill xxx</code>命令。并使用<code>docker rm -fv rancher-agent</code>命令</li><li>修改文件<code>vim /etc/docker/daemon.json</code>，在其中添加DNS地址。实验室机房DNS地址为：10.8.8.8以及10.8.4.4。</li></ol><pre><code>{        &quot;dns&quot; : [                &quot;114.114.114.114&quot;,                &quot;8.8.8.8&quot;        ],        &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], #镜像加速地址}</code></pre><h4 id="启动本地注册表"><a href="#启动本地注册表" class="headerlink" title="启动本地注册表"></a>启动本地注册表</h4><p><code>docker run -d -p 5000:5000 --restart=always --name registry registry:2</code></p><h1 id="Strategy-Service"><a href="#Strategy-Service" class="headerlink" title="Strategy Service"></a>Strategy Service</h1><h2 id="虚拟环境安装"><a href="#虚拟环境安装" class="headerlink" title="虚拟环境安装"></a>虚拟环境安装</h2><pre><code>$ pip3 install virtualenv$ pip3 install virtualenvwrapper</code></pre><p>安装环境后如果提示找不到<code>mkvirtualenv</code>命令，需要在配置。</p><pre><code># 1、在~（家目录）下创建目录用来存放虚拟环境mkdir .virtualenvs# 2、打开~/.bashrc文件，并添加如下：export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh# 3、运行source ~/.bashrc</code></pre><p>如果出现<code>ERROR: virtualenvwrapper could not find virtualenv in your path</code>，更改~/.bashrc配置如下：</p><pre><code>export WORKON_HOME=~/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3# 指定virtualenv的路径export VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenvsource /usr/local/bin/virtualenvwrapper.sh</code></pre><p>使用<code>mkvirtualenv -p python3 [name]</code>命令创建虚拟环境。</p><p>查看所有虚拟环境的命令：<code>workon</code>。使用虚拟环境：<code>workon [name]</code>。推出虚拟环境：<code>deactive</code>。删除虚拟环境：<code>rmvirtualenv [name]</code>。</p><p>在<code>strategy-service</code>目录下，通过<code>pip3 install -r requirement.txt</code>安装依赖。</p><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>安装<code>thrift</code>以及<code>hiredis</code>。<a href="https://mirrors.cnnic.cn/apache/thrift/0.13.0/" target="_blank" rel="noopener">thrift</a> <a href="https://github.com/redis/hiredis" target="_blank" rel="noopener">redis</a></p><p>安装<code>thrift</code></p><pre><code>$ ./config$ make$ make install$ thrift -version</code></pre><p>安装<code>hiredis</code></p><pre><code>$ make$ make install$ ldconfig /usr/local/lib</code></pre><p>安装<code>libevent</code>。<a href="https://github.com/libevent/libevent" target="_blank" rel="noopener">libevent</a></p><pre><code>$ ./configure --prefix=/usr/local/libevent$ make$ make install</code></pre><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在<code>strategy-service</code>文件夹中，执行：<code>python3 main.py run -f ./examples/01-single_avg.py</code></p>]]></content>
    
    
    <categories>
      
      <category>实验室</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验室</tag>
      
      <tag>回测系统</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOS设计器/套打设计器</title>
    <link href="/2020/07/22/BOS%E8%AE%BE%E8%AE%A1%E5%99%A8-%E5%A5%97%E6%89%93%E8%AE%BE%E8%AE%A1%E5%99%A8/"/>
    <url>/2020/07/22/BOS%E8%AE%BE%E8%AE%A1%E5%99%A8-%E5%A5%97%E6%89%93%E8%AE%BE%E8%AE%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="http://club.kisdee.com" target="_blank" rel="noopener">论坛</a> <a href="http://open.kingdee.com/K3cloud/SDK/webframe.html" target="_blank" rel="noopener">SDK</a> <a href="http://open.kingdee.com/K3cloud/WenKu/Index.aspx" target="_blank" rel="noopener">文档中心</a></p><p>简单账表-&gt;(树形账表、分页账表)</p><h1 id="插件学习"><a href="#插件学习" class="headerlink" title="插件学习"></a>插件学习</h1><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><p>表格名&lt;30字符，{ISV标识}_T_{子系统}_{表名}</p><h3 id="报表属性"><a href="#报表属性" class="headerlink" title="报表属性"></a>报表属性</h3><h4 id="ReportProperty属性"><a href="#ReportProperty属性" class="headerlink" title="ReportProperty属性"></a>ReportProperty属性</h4><ul><li><p>IdentityFieldName</p><p>分页顺序字段名，实模式取数必须设置，插件可以修改</p></li><li><p>GroupSummaryInfoData</p><p>分组信息数据（包含默认分组字段、分组级次字段等信息）</p></li><li><p>IsDefaultOnlyDspSumAndDetailData</p><p>默认只显示合计和明细数据，不显示小计数据</p></li><li><p>IsGroupSummary</p><p>标识报表是否支持分组汇总</p></li><li><p>IsUIDesignerColumns</p><p>标识报表的列必须通过UI设计，不考虑动态列</p></li><li><p>SimpleAllCols</p><p>是否锁定表格列</p></li><li><p>VirtualMode</p><p>是否虚模式取数</p></li><li><p>ReportName</p><p>报表名称</p></li><li><p>DetailReportId</p><p>明细报表的FormId(报表表单标识)，用于单明细报表</p></li><li><p>DetailReportFormIdFieldName</p><p>明细报表的FormId存储字段名，用于多明细报表</p></li><li><p>DetailReportType</p><p>明细报表类型</p></li><li><p>BillKeyFieldName</p><p>联联单据主键字段名</p></li><li><p>BillTypeFieldName</p><p>联查单据对应的单据类型名称</p></li><li><p>FormIdFieldName</p><p>联联单据FormId字段名</p></li><li><p>DecimalControlFieldList</p><p>精度控制字段集合</p></li></ul><h4 id="IRptParams参数的属性和方法"><a href="#IRptParams参数的属性和方法" class="headerlink" title="IRptParams参数的属性和方法"></a>IRptParams参数的属性和方法</h4><ul><li><p>CurrentPosition</p><p>报表当前位置,除分页报表外，该值始终是0</p></li><li><p>StartRow</p><p>报表取数开始行号</p></li><li><p>EndRow</p><p>报表取数结束行号</p></li><li><p>IsRefresh</p><p>报表是否重新刷新取数</p></li><li><p>IsOnlyQuerySumData</p><p>只查询汇总数据</p></li><li><p>FilterParameter</p><p>过滤条件</p></li><li><p>ParameterData</p><p>用户参数</p></li><li><p>CustomParams</p><p>报表其他参数，可以任意添加（如发布报表定义的参数）</p></li><li><p>FilterFieldInfo</p><p>过滤字段元数据信息</p></li><li><p>GetParentReportFilter()</p><p>获得父报表过滤条件</p></li><li><p>GetParentReportCurrentRow()</p><p>获得父报表当前行数据</p></li><li><p>GetFirstParentReportFilter() </p><p>报表穿透，获得第一个报表的过滤条件</p></li><li><p>GetParentReportCurrentConditionData()</p><p>获得父报表是分页报表的当前分页条件</p></li></ul><h3 id="需要引用的组件"><a href="#需要引用的组件" class="headerlink" title="需要引用的组件"></a>需要引用的组件</h3><pre><code>Kingdee.BOSKingdee.BOS.AppKingdee.BOS.ContractsKingdee.BOS.CoreKingdee.BOS.DataEntity</code></pre><h2 id="动态表单插件"><a href="#动态表单插件" class="headerlink" title="动态表单插件"></a>动态表单插件</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p>插件基类在<code>Kingdee.BOS.Core.dll</code>中。</p><div class="table-container"><table><thead><tr><th>领域类型</th><th>基类</th><th>命名参考</th></tr></thead><tbody><tr><td>动态表单  –  维护</td><td>AbstractDynamicFormPlugIn</td><td>ExpressionEdit</td></tr><tr><td>业务单据  –  维护</td><td>AbstractBillPlugIn</td><td>PurchaseOrderEdit</td></tr><tr><td>业务单据 – 列表</td><td>AbstractListPlugIn</td><td>PurchaseOrderList</td></tr><tr><td>基础资料  –  维护</td><td>AbstractBasePlugIn</td><td>MaterialEdit</td></tr><tr><td>基础资料  –  列表</td><td>AbstractListPlugIn</td><td>MaterialList</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>业务模型</th><th>类（插件）</th><th>继承自抽象类</th></tr></thead><tbody><tr><td>表单插件</td><td>单据插件</td><td>Kingdee.BOS.Core. Bill.PlugIn.AbstractBillPlugIn</td></tr><tr><td></td><td>基础资料插件</td><td>Kingdee.BOS.Core.  Base.PlugIn.AbstractBasePlugIn</td></tr><tr><td></td><td>动态表单插件</td><td>Kingdee.BOS.Core.  DynamicForm.PlugIn.AbstractDynamicFormPlugIn</td></tr><tr><td>列表插件</td><td>列表插件</td><td>Kingdee.BOS.Core.  List.PlugIn.AbstractListPlugIn</td></tr></tbody></table></div><h4 id="动态表单插件-1"><a href="#动态表单插件-1" class="headerlink" title="动态表单插件"></a>动态表单插件</h4><p>命名空间<code>Kingdee.BOS.Core.DynamicForm.PlugIn</code>。抽象类<code>AbstractDynamicFormPlugIn</code></p><ul><li>接口<ul><li>IDynamicFormViewPlugIn</li><li>IDynamicFormModelPlugIn</li></ul></li><li>加载机制<ul><li>OnInitialize</li><li>CreateNewData / AfterCreateNewData</li><li>BeforeBindData / AfterBindData</li><li>BeforeClosed</li></ul></li><li>表单操作<ul><li>BeforeDoOperation / AfterDoOperation</li><li>BeforeF7Select / AfterF7Select</li><li>TabItemSelectedChange</li></ul></li><li>表单事件<ul><li>BarItemClick</li><li>EntryBarItemClick</li><li>ToolBarItemClick</li><li>ButtonClick</li><li>EntityRowClick</li><li>EntityRowDoubleClick</li><li>EntryButtonCellClick</li></ul></li><li>模型访问操作<ul><li>BeforeUpdateValue</li><li>BeforeDeleteRow</li><li>AfterDeleteRow</li></ul></li></ul><h4 id="单据插件（继承动态表单）"><a href="#单据插件（继承动态表单）" class="headerlink" title="单据插件（继承动态表单）"></a>单据插件（继承动态表单）</h4><ul><li>接口<ul><li>IBillViewPlugIn<ul><li>OnBillInitialize</li><li>参数BillOpenParameter</li></ul></li><li>IBillModelPlugIn<ul><li>BeforeSave / AfterSave</li><li>BeforeSubmit / AfterSubmit</li></ul></li></ul></li></ul><h4 id="列表插件（继承动态表单）"><a href="#列表插件（继承动态表单）" class="headerlink" title="列表插件（继承动态表单）"></a>列表插件（继承动态表单）</h4><ul><li>接口<ul><li>IListViewPlugIn<ul><li>OnListInitialize</li><li>参数ListOpenParameter</li></ul></li><li>AfterGetData</li><li>FormatCellValue</li><li>IListModelPlugIn<ul><li>PrepareFilterParameter</li><li>BatchCopyData</li></ul></li><li>IListFilterView</li><li>IListFilterModel</li></ul></li></ul><h4 id="过滤条件插件"><a href="#过滤条件插件" class="headerlink" title="过滤条件插件"></a>过滤条件插件</h4><ul><li>接口<ul><li>IListFilterView</li><li>IListFilterModel</li></ul></li><li><p>IListFilterModel</p><ul><li>FilterObject</li><li>QuickFilterObject</li><li>IsolationOrgId</li><li>GetFilterField</li></ul></li><li><p>事件</p><ul><li>OnParseSetting</li><li>FireBeforeBindFilterMetadata</li><li>FireBeforeSelectTreeNodeScheme</li></ul></li></ul><h3 id="插件开发步骤"><a href="#插件开发步骤" class="headerlink" title="插件开发步骤"></a>插件开发步骤</h3><ul><li><p>定义插件类（参照继承体系）；</p></li><li><p>分析业务定义重载方法；</p></li><li><p>引用相关组件（参照组件引用规则）；</p></li><li><p>重载方法编码；</p></li><li><p>设置编译路径，编译组件；</p></li><li><p>打开IDE设计器，配置插件；</p></li></ul><h2 id="插件模型"><a href="#插件模型" class="headerlink" title="插件模型"></a>插件模型</h2><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="http://image.chensh236.com/%E6%9E%84%E6%9E%B6%E5%9B%BE.png" srcset="/img/loading.gif" alt="构架图"></p><h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p><img src="http://image.chensh236.com/%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="模型图"></p><h3 id="动态表单视图"><a href="#动态表单视图" class="headerlink" title="动态表单视图"></a>动态表单视图</h3><ul><li>管理界面控件外观及样式<ul><li>表单外观</li><li>控件外观</li><li>字段外观</li></ul></li><li>接口<ul><li>IDynamicFormView</li><li>IDynamicFormViewService</li></ul></li><li>2个重要的属性<ul><li>BusinessInfo</li><li>LayoutInfo</li></ul></li><li>界面元素访问<ul><li>访问菜单<ul><li>this.View.GetMainBarItem</li><li>this.View.GetBarItem</li></ul></li><li>访问字段<ul><li>this.View.GetFieldEditor</li><li>this.View.LockField</li><li>this.View.SetFormTitle</li></ul></li></ul></li><li>执行操作<ul><li>ShowForm</li><li>UpdateView</li><li>InvokeFieldUpdateService</li></ul></li></ul><h3 id="动态表单模型"><a href="#动态表单模型" class="headerlink" title="动态表单模型"></a>动态表单模型</h3><ul><li>管理业务逻辑与业务规则<ul><li>表单操作</li><li>表单服务</li><li>业务规则</li><li>校验器</li></ul></li><li>接口<ul><li>IDynamicFormView</li><li>IDynamicFormModelService</li></ul></li><li>2个重要的属性<ul><li>BusinessInfo</li><li>DataObject</li></ul></li><li>数据操作<ul><li>CreateNewData</li><li>CreateNewEntryRow</li><li>InsertEntryRow</li><li>GetEntryCurrentRowIndex</li><li>LoadReferenceData</li><li>GetValue</li><li>GetEntityDataObject</li></ul></li></ul><h2 id="服务插件"><a href="#服务插件" class="headerlink" title="服务插件"></a>服务插件</h2><p>命名空间：<code>Kingdee.BOS.Core.DynamicForm.PlugIn</code></p><p>抽象类：<code>AbstractOperationServicePlugIn</code></p><h3 id="继承体系-1"><a href="#继承体系-1" class="headerlink" title="继承体系"></a>继承体系</h3><div class="table-container"><table><thead><tr><th><strong>业务模型</strong></th><th><strong>继承自抽象类</strong></th></tr></thead><tbody><tr><td><strong>服务插件</strong></td><td>Kingdee.BOS.Core.DynamicForm.PlugIn.AbstractOperationServicePlugIn</td></tr></tbody></table></div><ul><li>接口<ul><li>IOperationServicePlugIn<ul><li>BeforeExecuteOperationTransaction</li><li>AfterExecuteOperationTransaction</li><li>BeginOperationTransaction</li><li>EndOperationTransaction</li></ul></li></ul></li><li>校验服务<ul><li>IOperationServicePlugIn<ul><li>OnAddValidators</li></ul></li><li>SaveValidator : AbstractValidator<ul><li>Validate</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>金蝶云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ERP</tag>
      
      <tag>金蝶云星空</tag>
      
      <tag>BOS设计器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金蝶云K3 Cloud安装</title>
    <link href="/2020/07/22/%E9%87%91%E8%9D%B6%E4%BA%91K3-Cloud%E5%AE%89%E8%A3%85/"/>
    <url>/2020/07/22/%E9%87%91%E8%9D%B6%E4%BA%91K3-Cloud%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="k3Cloud本体安装"><a href="#k3Cloud本体安装" class="headerlink" title="k3Cloud本体安装"></a>k3Cloud本体安装</h2><p>根据金蝶云安装指南进行安装。在安装时Windows10 除了MSDTC没有打开，其余已经打开，这里记录MSDTC在<code>Windows 10 Pro</code>下的打开过程。</p><p>Win + R打开运行，输入dcomcnfg打开组件服务窗口。之后在组件服务-&gt;计算机-&gt;我的电脑-&gt;Distributed Transaction Coordinators-&gt;本地DTC。打开属性，进入安全Tab，打开网络DTC访问，允许本地、远程、出站、入站。</p><h2 id="SQL-Server服务"><a href="#SQL-Server服务" class="headerlink" title="SQL Server服务"></a>SQL Server服务</h2><p><a href="https://go.microsoft.com/fwlink/?linkid=866662" target="_blank" rel="noopener">SQL Server Developer</a>是SQL Server的全功能免费版本，适用于非生产环境。另外，需要安装<code>SQL Server Management Studio(SSMS)</code>便于对<code>SQL Server</code>进行管理。<a href="https://aka.ms/ssmsfullsetup" target="_blank" rel="noopener">SSMS下载地址</a></p><p>创建数据库，默认的管理员账户为<code>sa</code>，登录身份认证使用<code>SQL Server</code>身份认证。让金蝶云能正常连接数据库的正常使用，需要创建非管理员账户，这里设定为<code>kingdee</code>。再对象资源管理器-&gt;安全性-&gt;登录名中添加，并添加用户名的角色。</p><h2 id="金蝶云星空管理中心"><a href="#金蝶云星空管理中心" class="headerlink" title="金蝶云星空管理中心"></a>金蝶云星空管理中心</h2><p>默认用户名<code>Administrator</code>，密码<code>888888</code>。需要创建数据中心，创建时需要键入SQL Server的管理员以及数据库用户的用户名密码。同时创建日志中心。等待数据中心创建后可以通过Web或者Client端登陆金蝶云星空。这里的地址为<a href="http://desktop-cudfdln/K3Cloud" target="_blank" rel="noopener">Web地址</a>。注意：多次出现语言未加载/获取语言失败的情况。登录管理中心后对数据中心进行语言设置即可解决。电脑重启后可能就会出现。</p><p>占用内存过大问题？</p><h2 id="BOS设计器安装"><a href="#BOS设计器安装" class="headerlink" title="BOS设计器安装"></a>BOS设计器安装</h2><p>在Web端的下载中心即可下载Client端以及BOS设计器、BOS套打设计器。设计器通过在线账户登录。</p>]]></content>
    
    
    <categories>
      
      <category>金蝶云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ERP</tag>
      
      <tag>金蝶云星空</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch学习笔记：torch的使用</title>
    <link href="/2020/07/16/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atorch%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/07/16/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atorch%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Pytorch学习：Tensor的使用"><a href="#Pytorch学习：Tensor的使用" class="headerlink" title="Pytorch学习：Tensor的使用"></a>Pytorch学习：Tensor的使用</h1><p>Ref: <a href="https://zhuanlan.zhihu.com/p/67184419" target="_blank" rel="noopener">知乎专栏</a> <a href="https://zhuanlan.zhihu.com/p/69294347" target="_blank" rel="noopener">知乎专栏</a></p><h2 id="Requires-grad"><a href="#Requires-grad" class="headerlink" title="Requires_grad"></a>Requires_grad</h2><p>如果对tensor无特殊的指定需求，不需要求导，通过<code>tensor.requires_grad</code>检查张量是否需要求导。如果输入中有需要求导的，则输出需要求导。当所有的输入都不需要求导的时候输出才不需要求导。</p><p>如果设置参数的导数为false，即<code>param.requires_grad = False</code>，可以冻结部分网络，让这些层数不再更新。</p><pre><code class="lang-python">input = torch.randn(8, 3, 50, 100)print(input.requires_grad)# Falsenet = nn.Sequential(nn.Conv2d(3, 16, 3, 1),                    nn.Conv2d(16, 32, 3, 1))for param in net.named_parameters():    param[1].requires_grad = False    print(param[0], param[1].requires_grad)# 0.weight False# 0.bias False# 1.weight False# 1.bias Falseoutput = net(input)print(output.requires_grad)# False</code></pre><h2 id="torch-no-grad"><a href="#torch-no-grad" class="headerlink" title="torch.no_grad()"></a>torch.no_grad()</h2><p>通过<code>with torch.no_grad()</code>达到暂时不追踪网络参数中导数的目的，减少计算和内存消耗。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p><code>x.view(x.size(0), -1)</code> =&gt; reshape</p><p><code>[weight].grad</code>获得导数</p><p><code>tensor.data</code>获得tensor数据</p><p><code>tensor.detach()</code>会自动求导系统追踪，存储空间是共享的。</p><p><code>device</code>减少<code>if</code>语句的使用。</p><pre><code class="lang-python">device = torch.device(&quot;cuda&quot;) if torch.cuda.is_available() else torch.device(&quot;cpu&quot;)a = torch.rand([3,3]).to(device)# 干其他的活b = torch.rand([3,3]).to(device)# 干其他的活c = torch.rand([3,3]).to(device)</code></pre><p>tensor-&gt;numpy = tensor-&gt;detach-&gt;numpy</p><pre><code class="lang-python">x  = torch.rand([3,3], device=&#39;cuda&#39;)x_ = x.cpu().numpy()y  = torch.rand([3,3], requires_grad=True, device=&#39;cuda&#39;).y_ = y.cpu().detach().numpy()# y_ = y.detach().cpu().numpy() 也可以# 二者好像差别不大？我们来比比时间：start_t = time.time()for i in range(10000):    y_ = y.cpu().detach().numpy()print(time.time() - start_t)# 1.1049120426177979start_t = time.time()for i in range(10000):    y_ = y.detach().cpu().numpy()print(time.time() - start_t)# 1.115112543106079# 时间差别不是很大，当然，这个速度差别可能和电脑配置# （比如 GPU 很贵，CPU 却很烂）有关。</code></pre><p>我们在提取 loss 的纯数值的时候，常常会用到 <code>loss.item()</code>，其返回值是一个 Python 数值 (python number)。不像从 tensor 转到 numpy (需要考虑 tensor 是在 cpu，还是 gpu，需不需要求导)，无论什么情况，都直接使用 <code>item()</code> 就完事了。如果需要从 gpu 转到 cpu 的话，PyTorch 会自动帮你处理。</p><p>但注意 <code>item()</code> 只适用于 tensor 只包含一个元素的时候。因为大多数情况下我们的 loss 就只有一个元素，所以就经常会用到 <code>loss.item()</code>。如果想把含多个元素的 tensor 转换成 Python list 的话，要使用 <code>tensor.tolist()</code>。</p><pre><code class="lang-python">x  = torch.randn(1, requires_grad=True, device=&#39;cuda&#39;)print(x)# tensor([-0.4717], device=&#39;cuda:0&#39;, requires_grad=True)y = x.item()print(y, type(y))# -0.4717346727848053 &lt;class &#39;float&#39;&gt;x = torch.randn([2, 2])y = x.tolist()print(y)# [[-1.3069953918457031, -0.2710231840610504], [-1.26217520236969, 0.5559719800949097]</code></pre><h2 id="叶子张量"><a href="#叶子张量" class="headerlink" title="叶子张量"></a>叶子张量</h2><p>使用<code>tensor.is_leaf</code>判断是否是叶子张量，在反向传播中，只有<code>is_leaf = True</code>的时候，需要求导的张量才会被保留下来。张量被用户创建时，设置<code>requires_grad = True</code>，它是一个叶子节点，如果它由其他运算操作产生，它就不是一个叶子节点。<code>tensor.retain_grad()</code>保留中间变量的导数。如果仅需要输出可以使用<code>tensor.register_hook(lambda grad: print(&#39;xx grad:&#39;, grad))</code></p><h2 id="inplace"><a href="#inplace" class="headerlink" title="inplace"></a>inplace</h2><p>不改变变量内存地址的情况下改变值。</p><pre><code class="lang-python"># 我们要用到 id() 这个函数，其返回值是对象的内存地址# 情景 1a = torch.tensor([3.0, 1.0])print(id(a)) # 2112716404344a = a.exp()print(id(a)) # 2112715008904# 在这个过程中 a.exp() 生成了一个新的对象，然后再让 a# 指向它的地址，所以这不是个 inplace 操作# 情景 2a = torch.tensor([3.0, 1.0])print(id(a)) # 2112716403840a[0] = 10print(id(a), a) # 2112716403840 tensor([10.,  1.])# inplace 操作，内存地址没变</code></pre><p>pytorch通过<code>tensor._version</code>检测是否发生了inplace。</p><h2 id="修改叶子节点"><a href="#修改叶子节点" class="headerlink" title="修改叶子节点"></a>修改叶子节点</h2><pre><code class="lang-python"># 方法一a = torch.tensor([10., 5., 2., 3.], requires_grad=True)print(a, a.is_leaf, id(a))# tensor([10.,  5.,  2.,  3.], requires_grad=True) True 2501274822696a.data.fill_(10.)# 或者 a.detach().fill_(10.)print(a, a.is_leaf, id(a))# tensor([10., 10., 10., 10.], requires_grad=True) True 2501274822696loss = (a*a).mean()loss.backward()print(a.grad)# tensor([5., 5., 5., 5.])# 方法二a = torch.tensor([10., 5., 2., 3.], requires_grad=True)print(a, a.is_leaf)# tensor([10.,  5.,  2.,  3.], requires_grad=True) Truewith torch.no_grad():    a[:] = 10.print(a, a.is_leaf)# tensor([10., 10., 10., 10.], requires_grad=True) Trueloss = (a*a).mean()loss.backward()print(a.grad)# tensor([5., 5., 5., 5.])</code></pre>]]></content>
    
    
    <categories>
      
      <category>PyTorch学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
      <tag>torch使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习笔记 - Chapter2</title>
    <link href="/2020/07/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Chapter2/"/>
    <url>/2020/07/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2-多臂赌博机"><a href="#Chapter-2-多臂赌博机" class="headerlink" title="Chapter 2 多臂赌博机"></a>Chapter 2 多臂赌博机</h1><h2 id="k臂赌博机问题"><a href="#k臂赌博机问题" class="headerlink" title="k臂赌博机问题"></a>k臂赌博机问题</h2><p>k臂赌博机有k个控制杆，需要学会将动作集中到最好的控制杆上。重复在k个选项或动作中做出选择，做出选择后得到一定数值的收益，收益由动作决定的<strong>平稳概率</strong>分布产生。</p><p>目标：最大化一段时间内的总收益。</p><p>任意动作a对应的价值为$q_*(a) $，是给定动作a时的收益期望：</p><script type="math/tex; mode=display">q_*(a)\doteq E[R_t | A_t = a]</script><p>动作a在时刻t的价值$Q<em>t(a)$希望接近$q</em>*(a)$。</p><p>讲对应最高估计价值的动作成为贪心(greedy)动作。选择贪心的动作为试探(exploration)，非贪心的动作为开发(exploitation)。</p><h2 id="动作-价值方法"><a href="#动作-价值方法" class="headerlink" title="动作-价值方法"></a>动作-价值方法</h2><p>动作的价值的真实值是选择这个动作的期望收益</p><script type="math/tex; mode=display">Q_t(a)\doteq \frac{\sum_{i = 1}^{t - 1} R_i  \cdot  1_{A_i = a}} {\sum_{i = 1}^{t - 1}1_{A_i = a}}</script><p>t时刻前通过执行动作a得到的收益总和 / 执行次数。大数定理：$Q<em>t(a) -&gt; q</em>*(a)$</p><p>贪心动作选择：</p><script type="math/tex; mode=display">A_t \doteq argmax_a Q_t(a)</script><p>$\epsilon-greedy$ 大部分时间贪心，偶尔独立于动作-价值估计方法从所有动作中等概率做出选择。</p><h2 id="增量式实现"><a href="#增量式实现" class="headerlink" title="增量式实现"></a>增量式实现</h2><p>动作-价值方法把动作价值作为观测到的收益的样本均值来估计。通过增量式实现高效计算均值。某个动作被选择n-1次之后的动作价值为：</p><script type="math/tex; mode=display">Q_n \doteq \frac{R_1 + R2 + ... + R_{n - 1}}{n-1}</script><p><img src="https://ftp.bmp.ovh/imgs/2020/07/2e638d7c1123f4fc.png" srcset="/img/loading.gif" alt=""></p><p>参数更新：新估计值&lt;-旧估计值+步长x[目标-旧估计值]</p><p>处理动作a的第n个收益使用的步长$\frac{1}{n}$，记为$\alpha$。</p><h2 id="非平稳问题"><a href="#非平稳问题" class="headerlink" title="非平稳问题"></a>非平稳问题</h2><p>取平均的方法对于平稳问题适合，但收益的概率随着时间变化而变化，使用固定步长对收益均值$Q_n$增量更新：</p><script type="math/tex; mode=display">Q_{n+1} \doteq Q_n + \alpha [R_n - Q_n]</script><p>推导：</p><p><img src="https://ftp.bmp.ovh/imgs/2020/07/40d5220b2b9dac81.png" srcset="/img/loading.gif" alt="c202"></p><p>$Q_{n + 1}$成为对过去收益和初始的估计$Q_1$的加权平均。权重值以指数形式递减，指数近因加权平均(exponential recency-weighted average)</p><h2 id="乐观-Optimistic-的初始值"><a href="#乐观-Optimistic-的初始值" class="headerlink" title="乐观(Optimistic)的初始值"></a>乐观(Optimistic)的初始值</h2><p>前面的Q值计算方法依赖$Q_1$，对于采样平均法(sample-average)，动作-价值方法,当所有动作至少选择一次则消失。对于a是常数项的情况，偏差随时间逐渐减小，并不会消失。$Q_1$可以作为超参数（先验知识）。$Q_1$过大-&gt;过度乐观的估计，因为无论哪个动作收益都比原来的小，倾向于使用其他动作。</p><h2 id="UCB-置信度上界的动作选择"><a href="#UCB-置信度上界的动作选择" class="headerlink" title="UCB 置信度上界的动作选择"></a>UCB 置信度上界的动作选择</h2><script type="math/tex; mode=display">A_t \doteq argmax_a [Q_t(a) + c\sqrt{\frac{ln t}{N_t(a)}}]</script><p>c &gt; 0, $N_t(a)$表示在t之前动作a被选择的次数。简单平稳问题可以提升性能，复杂非平稳问题不可用（处理大的状态空间）。</p><h2 id="梯度赌博机算法"><a href="#梯度赌博机算法" class="headerlink" title="梯度赌博机算法"></a>梯度赌博机算法</h2><p>引入数值化偏好函数(preference)$H_t$</p><script type="math/tex; mode=display">Pr\{A_{t} = a\} = \frac{e^{H_t(a)}}{\sum_{b=1}^{k}e^{H_t(b)}} = \pi_t{a}</script><p>$\pi_t(a)$表示动作a在t时刻被选择的概率。</p><script type="math/tex; mode=display">H_{t+1}(a) = H_{t}(a) - \alpha(R_t - \bar{R_t})(1-\pi_t(a))</script><p>$\bar{R_t}$: t时刻内收益的平均值，作为基准收益，如果高于它，选择该动作概率增加。</p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
      <tag>第二章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu18.04配置</title>
    <link href="/2020/07/13/Ubuntu18-04%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/07/13/Ubuntu18-04%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Tpoyra安装"><a href="#Tpoyra安装" class="headerlink" title="Tpoyra安装"></a>Tpoyra安装</h2><pre><code>$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE$ sudo add-apt-repository &#39;deb http://typora.io linux/&#39;$ sudo apt-get update$ sudo apt-get install typora</code></pre><h2 id="KXSW"><a href="#KXSW" class="headerlink" title="KXSW"></a>KXSW</h2><p><code>bash &lt;(curl -s -L http://dl.thinker.ink/install.sh)</code></p><h2 id="deep-in-container安装"><a href="#deep-in-container安装" class="headerlink" title="deep-in-container安装"></a>deep-in-container安装</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wszqkzqk/deepin-wine-ubuntu">Deepin wine Buntu</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wszqkzqk/deepin-wine-containers-for-ubuntu">Deepin wine containers for Ubuntu</a></p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在Ubuntu18.04中，可以通过“软件和更新”中修改源。</p><p>另外也可以通过修改<code>vim /etc/apt/source.list</code>文件，并执行：</p><pre><code>$ sudo apt-get update$ sudo apt-get upgrade</code></pre><p>实现源的更新。</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><h2 id="figlet（终端下的艺术字）"><a href="#figlet（终端下的艺术字）" class="headerlink" title="figlet（终端下的艺术字）"></a>figlet（终端下的艺术字）</h2><pre><code>$ sudo apt-get install figlet$ echo chensh236 | figlet</code></pre><h2 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h2><p><a href="https://link.zhihu.com/?target=http%3A//www.wps.cn/product/wpslinux">WPS</a></p><h2 id="indicator-multiload"><a href="#indicator-multiload" class="headerlink" title="indicator-multiload"></a>indicator-multiload</h2><p><code>sudo apt install indicator-multiload</code></p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu18.04</tag>
      
      <tag>服务部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu18.04 GPU服务器部署记录</title>
    <link href="/2020/07/03/GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/03/GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="硬盘挂载"><a href="#硬盘挂载" class="headerlink" title="硬盘挂载"></a>硬盘挂载</h2><p>输入<code>sudo fdisk -l</code>，查看信息。</p><p>格式化硬盘：<code>sudo mkfs.ext4 /dev/sda</code>。</p><p>创建目录：<code>mkdir /data</code>。</p><p>挂载分区：<code>sudo mount /dev/sda /data</code></p><p>查看UUID：<code>sudo blkid</code></p><p>复制对应的UUID，在<code>/etc/fstab</code>中进行修改：<code>UUID=[] /data ext4 defaults 0 1</code><br>之后执行命令<code>sudo mount -a</code>挂载硬盘。</p><p>注：取消挂载<code>umount /dev/sda</code></p><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>输入命令<code>chmod -R 777 [dir]</code>，为文件夹设置权限，所有用户可以访问。</p><h2 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h2><h3 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h3><p>输入命令<code>sudo vim /etc/modprobe.d/blacklist.conf</code>。<br>在末尾添加：</p><pre><code>blacklist nouveauoptions nouveau modeset=0</code></pre><p>安装gcc:</p><pre><code>$ sudo apt-get install gcc-5$ sudo apt-get install g++-5$ cd /usr/bin$ sudo rm gcc$ ln -s gcc-5 gcc$ sudo rm g++$ ln -s g++-5 g++</code></pre><h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p><code>sudo apt install build-essential</code></p><p>安装驱动（如果在Destkop模式下需要按Alt + F2进入命令行模式）：<code>sudo ./NVIDIA-Linux-x86_64-410.78.run</code></p><p>通过<code>nvidia-smi</code>查看驱动是否存在。</p><h2 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h2><p>安装cuda命令：</p><pre><code>sudo chmod +x cuda_9.0.176_384.81_linux-runsudo ./cuda_9.0.176_384.81_linux-run</code></pre><p>如果安装失败缺少toolkit，则通过<code>apt-get install</code>安装</p><p><code>sudo apt install nvidia-cuda-toolkit</code></p><p>通过<code>nvcc -V</code>进行测试。</p><p>在文件<code>~/.bashrc</code>与<code>/etc/profile</code>中添加：</p><pre><code>export PATH=/usr/local/cuda-9.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-9.0/lib64:/usr/local/cuda/extras/CUPTI/lib64/:$LD_LIBRARY_PATH</code></pre><p>之后source即可。</p><h2 id="安装cudnn"><a href="#安装cudnn" class="headerlink" title="安装cudnn"></a>安装cudnn</h2><pre><code>tar -zxvf cudnn-9.0-linux-x64-v7.tgz  sudo cp cuda/include/cudnn.h /usr/lib/cuda/include  sudo cp cuda/lib64/libcudnn* /usr/lib/cuda/lib64  sudo chmod a+r /usr/lib/cuda/include/cudnn.h /usr/lib/cuda/lib64/libcudnn*</code></pre><h3 id="vnc设置"><a href="#vnc设置" class="headerlink" title="vnc设置"></a>vnc设置</h3><pre><code>sudo apt-get updatesudo apt install xfce4 xfce4-goodies tightvncserver</code></pre><p>初始密码设置为970926</p><p>关闭窗口：<code>vncserver -kill :2</code></p><p>在目录<code>~/.vnc/xstartup</code>中，添加：</p><pre><code>#!/bin/bashxrdb $HOME/.Xresourcesstartxfce4 &amp;</code></pre><p>输入命令<code>sudo chmod +x ~/.vnc/xstartup</code>，启动vnc:<code>vncserver</code>。</p><h3 id="matlab-r2017b"><a href="#matlab-r2017b" class="headerlink" title="matlab r2017b"></a>matlab r2017b</h3><pre><code>$ mkdir /home/&lt;user name&gt;/Matlab$ sudo mount -t auto -o loop *dvd1.iso所在的绝对路径 /home/&lt;user name&gt;/Matlab# 不能在在安装目录下$ sudo /挂载目录/install</code></pre>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>GPU服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下的gitLab部署</title>
    <link href="/2020/05/13/Ubuntu%E4%B8%8B%E7%9A%84gitLab%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/05/13/Ubuntu%E4%B8%8B%E7%9A%84gitLab%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下的gitLab部署"><a href="#Ubuntu下的gitLab部署" class="headerlink" title="Ubuntu下的gitLab部署"></a>Ubuntu下的gitLab部署</h1><h2 id="Gitlab部署"><a href="#Gitlab部署" class="headerlink" title="Gitlab部署"></a>Gitlab部署</h2><p>安装依赖：</p><pre><code>$ sudo apt-get update$ sudo apt-get install -y curl openssh-server ca-certificates# 安装postfix，选择Internet Site$ sudo apt-get install -y postfix$ curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash$ sudo apt-get install gitlab-ee</code></pre><h2 id="Nginx反代理"><a href="#Nginx反代理" class="headerlink" title="Nginx反代理"></a>Nginx反代理</h2><p>将<code>/etc/gitlab/gitlab.rb</code>中的729行、731行改为</p><pre><code>gitlab_workhorse[&#39;listen_network&#39;] = &quot;tcp&quot;gitlab_workhorse[&#39;listen_addr&#39;] = &quot;127.0.0.1:[port]&quot;</code></pre><p>其中[port]为自定义端口，需要与nginx的反代理端口一致。</p><p>运行<code>sudo gitlab-ctl reconfigure</code>更改生效。</p><p>在nginx配置文件中，增加gitlab服务:</p><pre><code>$ sudo vim /etc/nginx/conf.d/gitlab.confserver {    listen       80;    server_name  lab.chensh236.com;    location / {        root  html;        index index.html index.htm;        proxy_pass http://127.0.0.1:[port];    }}</code></pre><p>运行<code>sudo systemctl restart nginx</code>生效。</p><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><pre><code>$ mkdir *$ chmod -R git:root *</code></pre><p>将<code>/etc/gitlab/gitlab.rb</code>中的484行改为新路径。</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>详见<a href="[https://blog.chensh236.com/2020/02/21/hexo%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B-%E5%88%9D%E7%BA%A7/](https://blog.chensh236.com/2020/02/21/hexo建站过程-初级/">hexo建站部分的nginx配置</a>)</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>在<code>gitlab.rb</code>中进行设置（620行）</p><pre><code>gitlab_rails[&#39;smtp_enable&#39;]=truegitlab_rails[&#39;smtp_address&#39;]=&quot;smtp.exmail.qq.com&quot;gitlab_rails[&#39;smtp_port&#39;]=465gitlab_rails[&#39;smtp_user_name&#39;]=&quot;name&quot; # 只填写账号gitlab_rails[&#39;smtp_password&#39;]=&quot;pass&quot;gitlab_rails[&#39;smtp_domain&#39;]=&quot;doamin.com&quot;gitlab_rails[&#39;smtp_authentication&#39;]=&quot;login&quot;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;]=truegitlab_rails[&#39;smtp_tls&#39;]=truegitlab_rails[&#39;gitlab_email_from&#39;]=&quot;name@domain.com&quot;</code></pre><p>执行<code>sudo gitlab_ctl reconfigure</code>即可。</p><h2 id="关于-Permission-denied"><a href="#关于-Permission-denied" class="headerlink" title="关于 Permission denied"></a>关于 Permission denied</h2><p>在Windows的凭据管理器中删除重新添加即可。</p><p><a href="https://blog.csdn.net/qq_34665539/article/details/80408282" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
      <category>GitLab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>GitLab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue实战课 小米商城3 环境设置和Mock</title>
    <link href="/2020/04/29/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E3-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%92%8CMock/"/>
    <url>/2020/04/29/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E3-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%92%8CMock/</url>
    
    <content type="html"><![CDATA[<h2 id="接口设置"><a href="#接口设置" class="headerlink" title="接口设置"></a>接口设置</h2><p>考虑三种跨域方式：CROS、JSONP、代理。</p><p>其中CROS、JSONP方式将baseURL封装入模块中，可以设置baseURL跟随不同的环境而变化。代理设置需要单独设置。</p><p>env.js</p><pre><code class="lang-javascript">let baseURL// CROS跨域，JSONP跨域使用，代理跨域不使用// web-pack 中有 --mode参数switch(process.env.NODE_ENV) {    case &#39;development&#39;:        baseURL = &#39;http://dev-mall-pre.springboot.cn/api&#39;        break    case &#39;test&#39;:        baseURL = &#39;http://test-mall-pre.springboot.cn/api&#39;        break    case &#39;production&#39;:        baseURL = &#39;http://mall-pre.springboot.cn/api&#39;        break    default:        baseURL = &#39;http://mall-pre.springboot.cn/api&#39;        break}export default {    baseURL}</code></pre><p>vue.config.js</p><pre><code class="lang-javascript">// 代理跨域使用module.exports = {    devServer:{        host: &#39;localhost&#39;,        port:8080,        proxy:{            &#39;/api&#39;:{                target: &#39;https://www.imooc.com&#39;,                changeOrigin: true,                pathRewrite:{                    &#39;/api&#39;: &#39;&#39;                }            }        }    }}</code></pre><h2 id="设置环境模式"><a href="#设置环境模式" class="headerlink" title="设置环境模式"></a>设置环境模式</h2><p>在<code>package.json</code>中设置环境的模式，如<code>&quot;serve&quot;: &quot;vue-cli-service serve --mode=development&quot;</code>。可有<code>development</code>、<code>test</code>、<code>production</code>。如需新增，可以在根目录创建<code>.env.[name]</code>，其中设置<code>NODE_ENV = &#39;[name]&#39;</code></p><h2 id="Mock设置"><a href="#Mock设置" class="headerlink" title="Mock设置"></a>Mock设置</h2><ul><li><p>本地创建json</p><pre><code class="lang-javascript">this.axios.get(&#39;/mock/user/login.json&#39;).then((res)=&gt;{      this.res = res    })</code></pre></li><li><p>easy-mock</p></li><li><p>集成Mock API (mock.js)</p></li></ul><p>在<code>/src/mock</code>中新建<code>api.js</code>：</p><pre><code class="lang-javascript">import Mock from &#39;mockjs&#39;Mock.mock(&#39;/api/user/login&#39;, {    &quot;status&quot;: 0,    &quot;data&quot;: {        &quot;id&quot;: 12,        &quot;username&quot;: &quot;admin&quot;,        &quot;email&quot;: &quot;admin@51purse.com&quot;,        &quot;phone&quot;: null,        &quot;role&quot;: 0,        &quot;createTime&quot;: 1479048325000,        &quot;updateTime&quot;: 1479048325000    }})</code></pre><p>在<code>main.js</code>中进行设置，注意使用require而不能是import，import在预编译阶段便进行加载，所有的请求会被Mockjs拦截。</p><pre><code class="lang-javascript">const mock = true/***  执行的时候加载*/if (mock){  require(&#39;./mock/api&#39;)}</code></pre><p>在请求时：</p><pre><code class="lang-javascript">this.axios.get(&#39;/user/login&#39;).then((res)=&gt;{      this.res = res      console.log(res)    })</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue实战1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue实战1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue实战课 小米商城1 脚手架和前端路由</title>
    <link href="/2020/04/26/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E1-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%92%8C%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/04/26/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E1-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%92%8C%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>在Node环境中，可以通过以下命令安装vue-cli：</p><pre><code>$ npm i -g @vue/cli# OR$ yarn global add @vue/cli</code></pre><p>如果<code>npm</code>速度较慢，可以使用<code>cnpm</code>，需要先安装<code>cnpm</code>：</p><pre><code>$  npm i -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>安装<code>vue-cli</code>后，可以通过<code>$ vue --version</code>查看<code>vue-cli</code>的版本。通过<code>$ vue create [project name]</code>创建新的vue项目。可以通过<code>vue ui</code>进入web界面对vue项目进行管理。</p><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>这里使用的是hash路由。在向后端发起请求时，hash路由的内容并不会发送到后端。使用ajax可以在不重新加载整个页面的情况下与后端交互更新部分内容。<br>该项目使用<code>axios</code>以代替<code>resource</code>，并且使用<code>vue-axios</code>将<code>axios</code>绑定在vue中，方便使用。<br><code>router.js</code>的定义如下：</p><pre><code class="lang-js">import Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;import Home from &#39;./pages/home&#39;import Index from &#39;./pages/index&#39;import Product from &#39;./pages/product&#39;import Detail from &#39;./pages/detail&#39;import Cart from &#39;./pages/cart&#39;import Order from &#39;./pages/order&#39;import OrderConfirm from &#39;./pages/orderConfirm&#39;import OrderList from &#39;./pages/orderList&#39;import OrderPay from &#39;./pages/orderPay&#39;Vue.use(Router)export default new Router({    routes:[        {            path: &#39;/&#39;,            name: &#39;home&#39;,            component: Home,            children: [                {                    path: &#39;/index&#39;,                    name: &#39;index&#39;,                    component: Index                },                {                    path: &#39;/product/:id&#39;,                    name: &#39;product&#39;,                    component: Product                },                {                    path: &#39;/detail/:id&#39;,                    name: &#39;detail&#39;,                    component: Detail                }            ]        },        {            path: &#39;/cart&#39;,            name: &#39;cart&#39;,            component: Cart        },        {            path: &#39;/order&#39;,            name: &#39;order&#39;,            component: Order,            children:[                {                    path: &#39;/list&#39;,                    name: &#39;order-list&#39;,                    component: OrderList                },                {                    path: &#39;/confirm&#39;,                    name: &#39;order-confirm&#39;,                    component: OrderConfirm                },                {                    path: &#39;/pay&#39;,                    name: &#39;order-pay&#39;,                    component: OrderPay                }            ]        },    ]})</code></pre><p>在<code>main.js</code>中，import该router对象，可以使用前端路由。</p>]]></content>
    
    
    <categories>
      
      <category>Vue实战1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue实战1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue实战课 小米商城2 Storage</title>
    <link href="/2020/04/26/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E2-Storage/"/>
    <url>/2020/04/26/Vue%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E2-Storage/</url>
    
    <content type="html"><![CDATA[<p>Storage与cookie的差别：</p><div class="table-container"><table><thead><tr><th>类别</th><th>Cookie</th><th>Storage</th></tr></thead><tbody><tr><td>大小</td><td>4KB</td><td>5MB</td></tr><tr><td>有效期</td><td>存在有效期</td><td>local storage永久存储, session storage浏览器打开期间有效</td></tr><tr><td>是否发送到服务端</td><td>是</td><td>否</td></tr><tr><td>路径限制</td><td>存在</td><td>存储于域名下</td></tr><tr><td>是否有特定API</td><td>有</td><td>无</td></tr></tbody></table></div><p>使用<code>window.sessionStorage</code>对session storage进行管理。</p><pre><code class="lang-js">/** * @abstract: Storage封装 */const STORAGE_KEY = &#39;mall&#39;export default{    // 存储值    setItem(key, value, module_name){        if(module_name){            let val = this.getItem(module_name)            this.setItem(module_name, val)        } else{            let val = this.getStorage()            val[key] = value            window.sessionStorage.setItem(STORAGE_KEY, JSON.stringify(val))        }    },    // 获取值    getItem(key, module_name){        if(module_name){            let val = this.getItem(module_name)            if(val) return val[key]        }        return this.getStorage()[key]    },    // 获取整个数据 STORAGE信息    getStorage(){        return JSON.parse(window.sessionStorage.getItem(STORAGE_KEY) || &#39;{}&#39;)    },    clear(key, module_name){        let val = this.getStorage()        if(module_name){            delete val[module_name][key]        } else{            delete val[key]        }        window.sessionStorage.setItem(STORAGE_KEY, JSON.stringify(val))    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue实战1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue实战1</tag>
      
      <tag>Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nextcloud优化</title>
    <link href="/2020/03/03/nextcloud%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/03/nextcloud%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>由于nextcloud提示了一些优化信息，这里进行优化。</p><h4 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h4><p>之前限制php-fpm的内存大小为512MB，需要进行更改，在<code>*php-fpm文件夹*/pool.d/www.conf</code>中设置<code>php_admin_value[memory_limit] = 2048M</code>即可。</p><h4 id="getenv-“PATH”-为空"><a href="#getenv-“PATH”-为空" class="headerlink" title="getenv(“PATH”)为空"></a>getenv(“PATH”)为空</h4><p>在前面提到的配置文件中将下面部分取消注释：</p><pre><code>env[HOSTNAME] = $HOSTNAMEenv[PATH] = /usr/local/bin:/usr/bin:/binenv[TMP] = /tmpenv[TMPDIR] = /tmpenv[TEMP] = /tmp</code></pre><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ul><li><p>HTTP 请求头 “X-Frame-Options” 没有配置为 “SAMEORIGIN”<br>在nginx的配置文件中</p></li><li><p>HTTP的请求头 “Strict-Transport-Security” 未设置为至少 “15552000” 秒</p></li><li>HTTP 头 “Referrer-Policy” 未设置成 “no-referrer”，”no-referrer-when-downgrade”，”strict-origin”，”strict-origin-when-cross-origin” 或 “same-origin”。这会泄露更多的信息</li><li>数据库中的一些列由于进行长整型转换而缺失。由于在较大的数据表重改变列类型会耗费一些时间，因此程序没有自动对其更改。您可以通过命令行手动执行 “occ db:convert-filecache-bigint” 命令以应用挂起的更改。该操作需要当整个实例变为离线状态后执行。查阅相关文档以获得更多详情。<ul><li>mounts.storage_id</li><li>mounts.root_id</li><li>mounts.mount_id</li></ul></li></ul><p>关于前两个问题，在nginx的配置文件中设置：</p><pre><code>add_header X-Frame-Options &quot;SAMEORIGIN&quot;;add_header Strict-Transport-Security &quot;max-age=31536000&quot;; includeSubDomains&quot; always;add_header Referrer-Policy &quot;no-referrer&quot;;</code></pre><p>重启服务即可。</p><p>关于最后一个问题，键入命令：<code>sudo -u www-data php /*nextcloud安装路径*/occ db:convert-filecache-bigint</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vsftpd使用</title>
    <link href="/2020/02/24/vsftpd%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/24/vsftpd%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vsftpd的使用"><a href="#vsftpd的使用" class="headerlink" title="vsftpd的使用"></a>vsftpd的使用</h1><p><a href="https://www.jianshu.com/p/1a8a4593958a" target="_blank" rel="noopener">参考文档</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>键入命令：<code>sudo apt-get install vsfptd</code></p><p>为了能够正常使用<code>ftp_TLS</code>，需要在<code>/etc/vsftpd.conf</code>中添加：</p><pre><code># 开启 ssl 并指定使用的协议ssl_enable=YESssl_tlsv1=YESssl_sslv2=NOssl_sslv3=NO# 指定证书和 key 文件rsa_cert_file=/*自己的目录*/*证书*.crtrsa_private_key_file=/*自己的目录*/*证书*.key# 安全选项allow_anon_ssl=NOforce_local_data_ssl=YESforce_local_logins_ssl=YESrequire_ssl_reuse=NOssl_ciphers=HIGH# 指定主动模式时使用的端口范围pasv_min_port=*自己设置端口*pasv_max_port=*自己设置端口*</code></pre><p>重启vsftpd服务即可。</p><h2 id="设置账户"><a href="#设置账户" class="headerlink" title="设置账户"></a>设置账户</h2><p><a href="https://www.cnblogs.com/lantor/p/7600247.html" target="_blank" rel="noopener">参考文档</a></p><p>需要添加账户，并指定主目录：<code>sudo useradd -d /*自己设置目录*/ -s /usr/sbin/nologin *用户名*</code>。之后设置密码：<code>passwd *用户名*</code></p><p>之后通过<code>chown *用户名*:*用户名* *目录*</code>设置文件夹权限。</p><p>下面完成两方面的设置：</p><ul><li>只允许特定用户登陆</li><li>只允许读写主目录</li></ul><pre><code>userlist_enable=YESuserlist_deny=NOuserlist_file=/etc/vsftpd/user_listchroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_listallow_writeable_chroot=YES</code></pre><p>其中，<code>chroot_list</code>中的用户可以访问主目录外的其他目录。</p><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>如果出现乱码问题，可以通过将文件系统字符集设置为<code>utf-8</code>解决。在<code>/etc/vsftpd.conf</code>中设置：<code>utf8_filesystem=YES</code>。在filezila中[站点]中的[字符集]强制使用<code>utf-8</code>编码即可。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>ftp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置nextcloud私有云盘服务</title>
    <link href="/2020/02/24/%E9%85%8D%E7%BD%AEnextcloud%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98%E6%9C%8D%E5%8A%A1/"/>
    <url>/2020/02/24/%E9%85%8D%E7%BD%AEnextcloud%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/843af0af176e" target="_blank" rel="noopener">参考文档1</a> <a href="https://blog.csdn.net/qq_35709559/article/details/89516063" target="_blank" rel="noopener">参考文档2</a></p><p>首先需要安装nginx服务：<code>sudo apt-get install nginx -y</code>。如果之前已经安装过不需要再次安装。</p><h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h2><p>这里使用php7.2，键入如下命令安装php以及相关依赖包：</p><pre><code>sudo apt-get install php7.2sudo apt-get install php-zipsudo apt-get install php-dompdfsudo apt-get install php-xmlsudo apt-get install php-mbstringsudo apt-get install php-curlsudo apt-get install php-mysql</code></pre><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>安装mysql：<code>sudo apt-get install -y mysql-server</code></p><p>输入<code>mysql -uroot -p</code>，如果出现如下错误：</p><pre><code>ERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39;</code></pre><p>这是因为第一次使用，未设置密码。需要键入<code>sudo systemctl stop mysql</code>停止mysql的运行。</p><p>键入命令：<code>sudo mysql_secure_installation</code>，进行管理员账户信息设置，并设置数据库的权限，按照自己需求设置即可。</p><p>键入命令<code>sudo systemctl start mysql</code>启动mysql。</p><p>如果前面设置了root用户远程登陆而之后需要取消，可以参考<a href="https://www.jianshu.com/p/3eb0bcf1448d" target="_blank" rel="noopener">这篇文档</a>。</p><p>正常进入mysql，键入命令：</p><pre><code>create database nextcloud;  # 新建show databases;             # 查看</code></pre><p>新建数据库用户：</p><pre><code>create user *用户名*@localhost identified by &#39;*密码*&#39;;</code></pre><p>限制数据库只可以本地访问并刷新：</p><pre><code>grant all privileges on nextcloud.* to *用户名*@localhost identified by &#39;*密码*&#39;;flush privileges;</code></pre><h2 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装nextcloud</h2><h2 id="设置nginx"><a href="#设置nginx" class="headerlink" title="设置nginx"></a>设置nginx</h2><p>进入<code>/etc/nginx/sites-available/</code>，创建文件cloud：<code>touch cloud</code>。之后在路径<code>/etc/nginx/sites-enabled/</code>中，加入软链接：<code>ln -s ../sites-available/cloud cloud</code>。</p><p>编辑<code>/etc/nginx/sites-available/cloud</code>（参见<a href="https://docs.nextcloud.com/server/12/admin_manual/installation/nginx.html" target="_blank" rel="noopener">官方配置</a>）：</p><pre><code>upstream php-handler {    server 127.0.0.1:9000;    #server unix:/var/run/php/php7.0-fpm.sock;}server {    listen 80;    listen [::]:80;    server_name disk.chensh236.com;    # enforce https    return 301 https://$server_name$request_uri;}server {    listen 443 ssl http2;    listen [::]:443 ssl http2;    server_name disk.chensh236.com;    ssl_certificate /*保存的目录*/*名字*.crt;    ssl_certificate_key /*保存的目录*/*名字*.key;    # Add headers to serve security related headers    # Before enabling Strict-Transport-Security headers please read into this    # topic first.    # add_header Strict-Transport-Security &quot;max-age=15768000;    # includeSubDomains; preload;&quot;;    #    # WARNING: Only add the preload option once you read about    # the consequences in https://hstspreload.org/. This option    # will add the domain to a hardcoded list that is shipped    # in all major browsers and getting removed from this list    # could take several months.    add_header X-Content-Type-Options nosniff;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Robots-Tag none;    add_header X-Download-Options noopen;    add_header X-Permitted-Cross-Domain-Policies none;    # Path to the root of your installation    root /*自己设置目录*/;    location = /robots.txt {        allow all;        log_not_found off;        access_log off;    }    # The following 2 rules are only needed for the user_webfinger app.    # Uncomment it if you&#39;re planning to use this app.    #rewrite ^/.well-known/host-meta /public.php?service=host-meta last;    #rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json    # last;    location = /.well-known/carddav {      return 301 $scheme://$host/remote.php/dav;    }    location = /.well-known/caldav {      return 301 $scheme://$host/remote.php/dav;    }    # set max upload size    client_max_body_size 512M;    fastcgi_buffers 64 4K;    # Enable gzip but do not remove ETag headers    gzip on;    gzip_vary on;    gzip_comp_level 4;    gzip_min_length 256;    gzip_proxied expired no-cache no-store private no_last_modified no_etag auth;    gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;    # Uncomment if your server is build with the ngx_pagespeed module    # This module is currently not supported.    #pagespeed off;    location / {        rewrite ^ /index.php$request_uri;    }    location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ {        deny all;    }    location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) {        deny all;    }    location ~ ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater/.+|ocs-provider/.+)\.php(?:$|/) {        fastcgi_split_path_info ^(.+?\.php)(/.*)$;        include fastcgi_params;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        fastcgi_param PATH_INFO $fastcgi_path_info;        fastcgi_param HTTPS on;        #Avoid sending the security headers twice        fastcgi_param modHeadersAvailable true;        fastcgi_param front_controller_active true;        fastcgi_pass php-handler;        fastcgi_intercept_errors on;        fastcgi_request_buffering off;    }    location ~ ^/(?:updater|ocs-provider)(?:$|/) {        try_files $uri/ =404;        index index.php;    }    # Adding the cache control header for js and css files    # Make sure it is BELOW the PHP block    location ~ \.(?:css|js|woff|svg|gif)$ {        try_files $uri /index.php$request_uri;        add_header Cache-Control &quot;public, max-age=15778463&quot;;        # Add headers to serve security related headers (It is intended to        # have those duplicated to the ones above)        # Before enabling Strict-Transport-Security headers please read into        # this topic first.        # add_header Strict-Transport-Security &quot;max-age=15768000; includeSubDomains; preload;&quot;;        #        # WARNING: Only add the preload option once you read about        # the consequences in https://hstspreload.org/. This option        # will add the domain to a hardcoded list that is shipped        # in all major browsers and getting removed from this list        # could take several months.        add_header X-Content-Type-Options nosniff;        add_header X-XSS-Protection &quot;1; mode=block&quot;;        add_header X-Robots-Tag none;        add_header X-Download-Options noopen;        add_header X-Permitted-Cross-Domain-Policies none;        # Optional: Don&#39;t log access to assets        access_log off;    }    location ~ \.(?:png|html|ttf|ico|jpg|jpeg)$ {        try_files $uri /index.php$request_uri;        # Optional: Don&#39;t log access to other assets        access_log off;    }}</code></pre><h2 id="nextcloud安装"><a href="#nextcloud安装" class="headerlink" title="nextcloud安装"></a>nextcloud安装</h2><p>在nextcloud<a href="https://nextcloud.com" target="_blank" rel="noopener">官网</a>查找服务端版本下载，尝试18.0.1出现了无法找到<code>File.php</code>的错误，所以选择17.0.3版本。如果下载过慢可以通过以下<a href="https://disk.chensh236.com/s/aJeyCDX5YKz8SsR" target="_blank" rel="noopener">链接</a>下载。将安装包上传到服务器上，并解压到对应目录即可。</p><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p>为了让nginx正常进行反向代理，需要让nginx的用户www-data有权限读写nextcloud文件夹中的文件。进入nextcloud对应的文件夹的父目录，键入命令：</p><pre><code>chown -R www-data:www-data nextcloud/chmod -R 755 nextcloud</code></pre><h3 id="9000端口没有监听问题："><a href="#9000端口没有监听问题：" class="headerlink" title="9000端口没有监听问题："></a>9000端口没有监听问题：</h3><p>将<code>cloud</code>文件中的<code>server 127.0.0.1:9000;</code>改为<code>server unix:/var/run/php/php7.2-fpm.sock;</code></p><h2 id="ACPu加速"><a href="#ACPu加速" class="headerlink" title="ACPu加速"></a>ACPu加速</h2><p>安装：<code>sudo apt-get install php-apcu -y</code></p><p>在nextcloud路径下的<code>config/config.php</code>中添加：</p><pre><code>&#39;memcache.local&#39; =&gt; &#39;\OC\Memcache\APCu&#39;,</code></pre><p>重启php7.2-fpm服务：<code>sudo systemctl reload php7.2-fpm.service</code>以及nginx：<code>sudo systemctl restart nginx</code>。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nextcloud</tag>
      
      <tag>维护</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo建站教程（初级）3——添加管理界面与评论</title>
    <link href="/2020/02/22/hexo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%893%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/"/>
    <url>/2020/02/22/hexo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%893%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="添加admin-hexo界面"><a href="#添加admin-hexo界面" class="headerlink" title="添加admin-hexo界面"></a>添加admin-hexo界面</h1><p><a href="https://jaredforsyth.com/hexo-admin/" target="_blank" rel="noopener">官网</a> <a href="https://albenw.github.io/posts/4ffa5bc6/" target="_blank" rel="noopener">参考文档1</a> <a href="https://blog.csdn.net/RenZouChaLiangrz/article/details/87890621" target="_blank" rel="noopener">参考文档2</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装admin-hexo之前需要安装一些依赖，避免错误发生。键入命令：</p><pre><code>npm install minimatch@&quot;3.0.2&quot;  npm update -d</code></pre><p>可以完成依赖的安装。之后键入命令<code>npm install --save hexo-admin</code>可以完成插件的安装。<br>执行<code>hexo s</code>命令，在<code>localhost:4000/admin</code>可以查看。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h3><p>在<code>Setting</code>界面，点击<code>Setup authentification here</code>，创建用户名和密码，按照提示在blog根目录中的<code>_config.yml</code>中添加该界面下方的设置。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>在blog根目录下，新建文件夹，进入后新建脚本<code>d.sh</code>，加入命令<br><code>hexo clean &amp; hexo g -d</code>，之后通过命令<code>chmod +x d.sh</code>设置权限。<br>最后一步在blog根目录下的<code>_config.yml</code>的<code>admin</code>部分添加：</p><pre><code>admin:  username: ...  password_hash: ...  secret: ...  deployCommand: ./*新建的文件夹名*/d.sh</code></pre><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>这部分比较简单，我是用的是valine。<a href="https://www.jianshu.com/p/728a9594bb6c" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站搭建</tag>
      
      <tag>博客</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo建站教程（初级）2 —— 百度和google的收录</title>
    <link href="/2020/02/22/hexo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B2/"/>
    <url>/2020/02/22/hexo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B2/</url>
    
    <content type="html"><![CDATA[<p>之前主要讲述了hexo的基础建站过程。即使站点搭的很漂亮，文章写的很漂亮，但因为没有google和百度的抓取，这些文章依然很难被别人看到。<br>下面主要讲述百度和google的站点地图提交和主动推送，以便百度和google收录和蜘蛛爬取。</p><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p><a href="https://zhuanlan.zhihu.com/p/100922816" target="_blank" rel="noopener">参考文档</a><br>在<a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">百度搜索资源平台</a>，可以添加自己的网站，需要选择http或者https协议。这里使用的是https协议。在此之后还需要进行验证。可以选择比较方便的DNS验证。</p><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><p>在blog的目录输入命令：<code>npm install hexo-baidu-url-submit --save</code>，在该目录的<code>_config.yml</code>文件中写入：</p><pre><code>baidu_url_submit:  count: 1                              # 提交最新的多少个链接  host: *自己的域名*                      # 在百度站长平台中添加的域名  token: *在百度搜索资源平台中获得的token*   # 秘钥  path: baidu_urls.txt                   # 文本文档的地址， 新链接会保存在此文本文档里</code></pre><p>之后需要检查url是否与百度验证的域名一致：</p><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: *自己的域名*</code></pre><p>检查完成，添加deployer：</p><pre><code>deploy:- type: git  repo:     github: ...    local:  ...  branch: master- type: baidu_url_submitter</code></pre><p>之后运行<code>hexo clean &amp; hexo g -d</code>查看能否正常推送。</p><h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>键入命令<code>npm install hexo-generator-baidu-sitemap --save</code>，安装对应的包。<br>在blog根目录中的<code>_config.yml</code>中加入</p><pre><code>baidusitemap:  path: baidusitemap.xml</code></pre><p>重新执行<code>hexo clean &amp; hexo g -d</code>就可以在<code>public</code>文件夹中看到对应的<code>baidusitemap.xml</code>文件。这说明站点地图建立成功。<br>将<code>https://*自己的域名*/baidusite.xml</code>提交到百度即可。</p><h2 id="google"><a href="#google" class="headerlink" title="google"></a>google</h2><p>google只使用站点地图提交，键入命令<code>npm install hexo-generator-sitemap --save</code>，安装对应的包。<br>在blog根目录中的<code>_config.yml</code>中加入</p><pre><code>sitemap:  path: sitemap.xml</code></pre><p>重新执行<code>hexo clean &amp; hexo g -d</code>，可以看到在<code>public</code>文件夹中有对应的<code>sitemap.xml</code>文件。<br>在google的<a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">站长平台</a>进行验证，提交站点地图即可，可以选用DNS验证比较方便。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站搭建</tag>
      
      <tag>博客</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo建站过程(初级)</title>
    <link href="/2020/02/21/hexo%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B-%E5%88%9D%E7%BA%A7/"/>
    <url>/2020/02/21/hexo%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B-%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-建站过程"><a href="#hexo-建站过程" class="headerlink" title="hexo 建站过程"></a>hexo 建站过程</h1><h2 id="初级：搭建hexo并部署本地服务器以及github"><a href="#初级：搭建hexo并部署本地服务器以及github" class="headerlink" title="初级：搭建hexo并部署本地服务器以及github"></a>初级：搭建hexo并部署本地服务器以及github</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo文档</a><br>hexo框架相关文档如上，相关介绍也都在上面，这里不再赘述。我主要阐述我自己部署hexo的过程，以供参考。由于懒得每次写作都需要进行一次部署，所以想要将hexo搭建在腾讯云服务器上，并且部署在本地的服务器以及github上。</p><pre><code>运行环境：本地: Mac OS / Window 10cvm: ubuntu</code></pre><h3 id="公钥免密登陆"><a href="#公钥免密登陆" class="headerlink" title="公钥免密登陆"></a>公钥免密登陆</h3><p>本地电脑生成公钥和私钥，将公钥上传到cvm上，本地使用私钥，可以实现免密登陆ssh。关于ssh使用的基于非对称加密算法的<code>rsa</code>算法，可以查看<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem" target="_blank" rel="noopener">wiki百科</a>)的介绍。</p><h4 id="本地电脑配置"><a href="#本地电脑配置" class="headerlink" title="本地电脑配置"></a>本地电脑配置</h4><p>使用命令：<code>ssh-keygen -t rsa</code>，一路回车即可生成一对公钥和私钥。公钥默认名为<code>id_rsa.pub</code>，私钥为<code>id_rsa</code>。存储位置如下：</p><ul><li>Windows：<code>C:\Users\*用户名*\.ssh\</code></li><li>Ubuntu / Mac OS：<code>~\.ssh</code></li></ul><h4 id="cvm配置"><a href="#cvm配置" class="headerlink" title="cvm配置"></a>cvm配置</h4><p>可以直接打开<code>id_rsa.pub</code>，复制内容或者通过SFTP上传到cvm上。cvm进行如下设置：</p><ul><li>确保连接成功，需要更改文件权限：</li></ul><pre><code>chmod 600 authorized_keys # 在~/.ssh/目录中执行chmod 700 ~/.ssh # 在~/目录中执行</code></pre><ul><li>写入公钥：</li></ul><pre><code>cat *公钥路径*/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre><ul><li>更改服务器配置，确保能够通过密钥登陆：</li></ul><p>修改配置文件：<code>sudo vim /etc/ssh/sshd_config</code>，添加（修改）如下参数：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesPermitRootLogin yes</code></pre><ul><li><p>可选择禁用密码登录：<code>PasswordAuthentication no</code></p></li><li><p>重启ssh服务：<code>service sshd restart</code></p></li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是否能直接通过私钥登陆ssh：<code>ssh -i *密钥所在路径* *用户名*@*服务器地址*</code></p><h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><p><a href="https://www.jianshu.com/p/9c1d3dcd8c99" target="_blank" rel="noopener">参考文档1</a> <a href="https://segmentfault.com/a/1190000009723457" target="_blank" rel="noopener">参考文档2</a></p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>在ubuntu下，输入命令<code>sudo apt-get install git-core</code>。</p><p>之后需要设置用户名以及邮箱。这里使用全局设置。</p><pre><code>git config --global user.name &quot;*用户名*&quot;git config --global user.email &quot;*邮箱*&quot;</code></pre><h4 id="安装node-js以及hexo"><a href="#安装node-js以及hexo" class="headerlink" title="安装node.js以及hexo"></a>安装node.js以及hexo</h4><ul><li>在ubuntu下安装node.js：</li></ul><pre><code>curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -sudo apt-get install -y nodejs</code></pre><ul><li>安装hexo：<code>npm install -g hexo-cli</code></li><li>如果出现<strong>EACCES</strong>错误，修改配置文件即可。<a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">参考连接</a><pre><code>mkdir ~/.npm-globalnpm config set prefix &#39;~/.npm-global&#39;export PATH=~/.npm-global/bin:$PATHsource ~/.profile#　测试sudo npm install -g jshint</code></pre>如果<code>npm</code>无法正常下载包，可以使用淘宝的源，输入命令：</li></ul><pre><code>npm install -g *cnpm*--registry=https://registry.npm.taobao.org</code></pre><p>之后使用<code>cnpm</code>代替<code>npm</code>即可。</p><ul><li>安装建站需要的其他包：</li></ul><pre><code>npm install -g hexo-servernpm install -g hexo-deployer-gitnpm install -g hexo-util</code></pre><h4 id="创建本地博客文件夹"><a href="#创建本地博客文件夹" class="headerlink" title="创建本地博客文件夹"></a>创建本地博客文件夹</h4><p>因为我在cvm使用了第二块数据盘，需要<code>sudo</code>权限才能够进行更改。故新建<code>blog</code>文件夹之后修改文件夹权限。</p><pre><code>sudo chown -R $USER:$USER blogsudo chmod -R 755 blog</code></pre><p>进入文件夹，初始化hexo：<code>hexo init .</code> 如果没有将hexo所在路径添加到环境变量中，需要使用<code>npx hexo init .</code></p><p>之后输入<code>hexo s</code>可以启动项目，在本地<code>localhost:4000</code>可以查看。</p><h4 id="将hexo部署到github上"><a href="#将hexo部署到github上" class="headerlink" title="将hexo部署到github上"></a>将hexo部署到github上</h4><p>在github上添加一个<code>repository</code>，名字<strong>必须</strong>是<code>*github用户名*.github.io</code>，否则会出现错误。复制远程git地址。</p><p>在博客所在文件夹中，编辑<code>_config.yml</code>，在文本最后的部署部分更改为：</p><pre><code>deploy:    type: git    repo:        github: *远程git地址*    branch: master</code></pre><p>保存后执行<code>hexo g -d</code>可以生成并部署，或者<code>hexo generate</code>之后<code>hexo deploy</code>亦可。</p><p>在部署过程中，需要输入用户名以及密码。如果以后懒得输入，可以使用如下命令，下次输入后不用再输入：</p><pre><code>git config --global credential.helper store</code></pre><h4 id="将hexo部署到本地"><a href="#将hexo部署到本地" class="headerlink" title="将hexo部署到本地"></a>将hexo部署到本地</h4><p>这里使用git将hexo部署到本地。首先需要创建文件夹，如果出现权限问题，可以参照前面的方法设置文件夹的权限。之后进入文件夹，创建裸仓：</p><pre><code>git init --bare hexo.gitchown -R $User:$User hexo.git</code></pre><p>进入<code>hexo.git</code>文件夹，找到<code>hooks</code>目录并进入，通过如下命令将<code>post-update.sample</code>文件改名为<code>post-update.sample</code>：</p><pre><code>mv post-update.sample post-update</code></pre><p>之后编辑该文件，在顶部加入：</p><pre><code>git --work-tree=*文件夹路径* --git-dir=*文件夹路径*/hexo.git checkout -f</code></pre><p>修改该文件权限：</p><pre><code>chmod +x post-update</code></pre><p>在博客文件夹中，修改<code>_config.yml</code>，将<code>deploy</code>部分改为：</p><pre><code>deploy:    type: git    repo:        github: *远程git地址*        repo: *文件夹路径*/hexo.git    branch: master</code></pre><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>nginx的<a href="https://blog.csdn.net/weixin_42167759/article/details/85049546" target="_blank" rel="noopener">配置文件解析</a></p><p>由于使用了https，所以nginx需要监听80端口，将http链接跳转为https链接。通过nginx配置https链接可以参考<a href="https://juejin.im/post/5c0144036fb9a04a102f046a" target="_blank" rel="noopener">nginx配置ssl实现https访问</a>，非常简单所以不再赘述。与基础配置不同的是需要添加<code>root</code>指向前面提到的hexo部署到本地的文件夹（下面有提示） ，并且添加<code>include mime.types;</code>确保<code>css</code>文件能够被浏览器正常识别。</p><ul><li>安装：<code>apt-get install nginx</code></li><li><p>查看位置/检查配置：<code>nginx -t</code></p></li><li><p>更改配置</p></li></ul><pre><code>user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events { worker_connections 768; # multi_accept on;}http { ## # Basic Settings ##include mime.types; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; server {      listen 443 ssl;      server_name *域名*;      ssl on;      ssl_certificate /*证书所在文件夹*/*证书*;      ssl_certificate_key /*密钥所在文件夹*/*密钥*;    root *hexo部署到本地的文件夹*;  location / {    index  index.html;  } } server {  listen 80;  server_name *域名*;  return 301 https://blog.chensh236.com$request_uri; }}</code></pre><ul><li>执行<code>nginx -t</code>与<code>nginx -s reload</code>（可能需要sudo）</li></ul><p>如若出现：</p><pre><code>nginx: [warn] the &quot;user&quot; directive makes sense only if the master process runs with super-user privileges, ignored in /usr/local/nginx/conf/nginx.conf:2</code></pre><p>需要解决权限占用问题：</p><pre><code>chown root.root nginxchmod 755 nginxchmod u+s nginx</code></pre><h5 id="重装nginx"><a href="#重装nginx" class="headerlink" title="重装nginx"></a>重装nginx</h5><p>如果nginx出现问题需要重装，其配置文件依旧存在，可以通过如下方法完全清除nginx相关的依赖、配置文件。</p><ul><li>卸载nginx不保留配置文件：<code>sudo apt-get --purge remove nginx</code></li><li>卸载不需要的依赖包：<code>sudo apt-get autoremove</code></li><li>筛选已经安装包中与nginx有关的：<code>dpkg --get-selections | grep nginx</code></li><li>卸载所有有关的：<code>sudo apt-get --purge remove *和nginx相关的安装包*</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站搭建</tag>
      
      <tag>博客</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
